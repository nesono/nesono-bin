#!/bin/zsh
# tmp/cache file to store the stack (array)
STACKFILE=/tmp/${USER}.TRANSSTACKFILE.txt

# function to push some files onto path transfer stack - utility for cp|mv
function pusht()
{
  # reload stack
  [ -r ${STACKFILE} ] && TRANSSTACK=("${(@Q)${(z)"$(cat -- ${STACKFILE})"}}")

  # set default mode
  MODE="cp -r"

  # check if any parameter given
  if [ -z "${1}" ]; then
    echo "usage: pusht [mv|cp] file|dir ..."
  fi

  # check first parameter for option (mv|cp)
  case "${1}" in
    mv )
    #echo "detected parameter $1"
    MODE="mv"
    shift
    ;;
    cp )
    # echo "detected parameter $1"
    MODE="cp -r"
    shift
    ;;
    "-h" )
    echo "usage: pusht [mv|cp] file|dir ..."
    return
    ;;
  esac

  # add remaining files/dirs to stack
  while [ -n "${1}" ]; do
    # convert relative paths to absolute ones
    local ABSPATH=$(rel2abs "${1}")
    # check if path exists
    if [ -e "${ABSPATH}" ]; then
      # append to STACK
      TRANSSTACK+="${MODE} '"${ABSPATH}"'"
    else
      echo "${ABSPATH}: no such file or directory - skipping"
    fi
    shift
  done

  # save stack to file
  print -r -- ${(qq)TRANSSTACK} > ${STACKFILE}
}

# function to apply path transfer stack values
function popt()
{
  # reload stack
  [ -r ${STACKFILE} ] && TRANSSTACK=("${(@Q)${(z)"$(cat -- ${STACKFILE})"}}")

  # sanity check for empty array
  cnt=${#TRANSSTACK}
  if [ ${cnt} -eq 0 ]; then
    echo "No items on stack!"
    return
  fi

  local suffix=''
  # check for first parameter
  case "${1}" in
    "-d" )
    # just delete the last stack item
    unset TRANSSTACK[${#TRANSSTACK}]

    # save stack to file
    print -r -- ${(qq)TRANSSTACK} > ${STACKFILE}
    return
    ;;
    "-a" )
    # apply all stack items
    for i in ${TRANSSTACK}; do
      local filename="${TRANSSTACK[$i]##*/}"
      filename="${filename%\'}"
      if [ -e "${filename}" ]; then
        suffix=0
        while [ -e "${filename}".${suffix} ]; do
          suffix=$(($suffix+1))
        done
        echo "-> ${TRANSSTACK[$i]} '""${filename}.${suffix}""'"
        eval ${TRANSSTACK[$i]} "'"${filename}.${suffix}"'"
      else
        echo "-> ${TRANSSTACK[$i]} ."
        eval ${TRANSSTACK[$i]} .
      fi
    done
    return
    ;;
    "-f" )
    # flush all transfers - just don't reinsert existing
    return
    ;;
    "-h" )
    echo "usage: popt [-d|-a|-f|-h]"
    echo "             -d    discard top transfer from stack"
    echo "             -a    apply all transfers in stack"
    echo "             -f    flush all transfers from stack"
    echo "                   apply top transfer from stack"
    echo "             -h    print this help text"

    # save stack to file
    print -r -- ${(qq)TRANSSTACK} > ${STACKFILE}
    return
    ;;
  esac

  # check if file already exists
  local filename="${TRANSSTACK[${#TRANSSTACK}]##*/}"
  filename="${filename%\'}"
  if [ -e "${filename}" ]; then
    suffix=0
    while [ -e "${filename}".${suffix} ]; do
      suffix=$(($suffix+1))
    done
    echo "-> ${TRANSSTACK[${#TRANSSTACK}]} '""${filename}.${suffix}""'"
    eval ${TRANSSTACK[${#TRANSSTACK}]} "'"${filename}.${suffix}"'"
  else
    # apply one item
    echo "-> ${TRANSSTACK[${#TRANSSTACK}]} ."
    eval ${TRANSSTACK[${#TRANSSTACK}]} .
  fi
  # pop last item
  unset TRANSSTACK[${#TRANSSTACK}]

  # save stack to file
  print -r -- ${(qq)TRANSSTACK} > ${STACKFILE}
}

# function to print all stacked transfers
function transfers()
{
  # reload stack
  [ -r ${STACKFILE} ] && TRANSSTACK=("${(@Q)${(z)"$(cat -- ${STACKFILE})"}}")

  # print exisiting stack values from environment
  for v in ${TRANSSTACK};do
    echo "${v}"
  done
}
